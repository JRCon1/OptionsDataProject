# -*- coding: utf-8 -*-
"""MainFile

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U5LC6I370y6tvy0_5WXuhMvG7hEqqQYM
"""

"""
options_test_run.py   —   one-shot snapshot into opts.xlsx
----------------------------------------------------------
• Pulls a filtered chain for each ticker in TICKERS
• Writes/overlays one sheet per run:  <TICKER>_<type>_<YYYY-MM-DD>
• Safe whether the workbook exists or not
"""

from pathlib import Path
from datetime import datetime, timedelta, date
import pandas as pd
import yfinance as yf

# ── User settings ──────────────────────────────────────────────
TICKERS  = ["SPY", "UPRO"]   # add / remove as needed
OPT_TYPE = "c"               # 'c' for calls, 'p' for puts
BOUND    = 0.20              # ±20 % moneyness window
MAX_DTE  = 120               # keep expiries ≤ 120 days
XLSX     = Path("opts.xlsx") # workbook name
# ───────────────────────────────────────────────────────────────


def get_options(ticker_symbol: str,
                opt_type: str = "c",
                bound: float = 0.2,
                max_dte: int = 120) -> pd.DataFrame:
    tk   = yf.Ticker(ticker_symbol)
    spot = tk.history(period="1d")["Close"].iloc[-1]

    lo, hi      = round(spot * (1 - bound), 0), round(spot * (1 + bound), 0)
    cutoff_date = datetime.utcnow() + timedelta(days=max_dte)
    timestamp   = datetime.now().replace(microsecond=0)

    rows = []
    for exp_str in tk.options:
        exp_date = pd.to_datetime(exp_str)
        if exp_date > cutoff_date:
            continue

        chain = tk.option_chain(exp_str)
        df    = chain.calls if opt_type == "c" else chain.puts
        df    = df.loc[
            df["strike"].between(lo, hi),
            ["contractSymbol", "strike",
             "lastPrice", "bid", "ask", "impliedVolatility"]
        ].copy()

        if df.empty:
            continue

        df["symbol"]          = ticker_symbol
        df["expiry"]          = exp_date
        df["downloaded_at"]   = timestamp
        df["underlying_price"] = round(spot, 2)   # ← NEW COLUMN
        rows.append(df)

    if not rows:
        return pd.DataFrame()

    out        = pd.concat(rows, ignore_index=True)
    now        = pd.Timestamp.now(tz=None)
    out["dte"] = (out["expiry"] - now).dt.days + 1
    return out[out["dte"] > 0]

def main() -> None:
    today    = date.today().isoformat()
    exists   = XLSX.exists()

    # Avoid overwriting the workbook by conditionally setting params
    if exists:
        writer = pd.ExcelWriter(
            XLSX,
            engine="openpyxl",
            mode="a",
            if_sheet_exists="overlay"  # overwrite matching sheets only
        )
    else:
        writer = pd.ExcelWriter(
            XLSX,
            engine="openpyxl",
            mode="w"
        )

    with writer as xl:
        for tk in TICKERS:
            df = get_options(tk, OPT_TYPE, BOUND, MAX_DTE)
            if df.empty:
                print(f"· {tk}: no rows matched filters")
                continue

            timestamp = datetime.now().strftime("%Y-%m-%d_%H%M")  # e.g. 2025-06-16_1300
            sheet = f"{tk}_{OPT_TYPE}_{timestamp}"

            if len(sheet) > 31:
                sheet = sheet[:31]  # Excel limit

            df.to_excel(xl, sheet_name=sheet, index=False)
            print(f"✔ {sheet:31s} rows={len(df):4d}")

if __name__ == "__main__":
    main()

